<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type" />
<title>Encoding</title></head>
<body>
<h3>Overview</h3>JRemoting has a number of 'transports' to connect
clients to servers. Some of the work over the internet, some are for
more local situations.<h3>Socket Transport</h3>This will work over the
internet or an intranet, between two different machines. &nbsp;It will
also work between two different processes on the same machine.<br /><span style="font-weight: bold;">Server side usage</span>
<div class="source">
<pre>server = new <span style="font-weight: bold;">SocketServer</span>(new ConsoleServerMonitor(), new InetSocketAddress(portNum));<br /></pre>
</div>
<p style="font-weight: bold;">Client side usage</p>
<div class="source">
<pre>jremotingClient = new JRemotingClient(new <span style="font-weight: bold;">SocketTransport</span>(new ConsoleClientMonitor(), new InetSocketAddress("somehost.com", portNum)));<br /></pre>
</div><h3>Secure Socket Transport</h3>As above, but using SSL. &nbsp;You need to set the keyStore and/or trustStore for the VM in question. See <br /><br /><span style="font-weight: bold;">Server side usage</span>
<div class="source">
<pre>-Djavax.net.ssl.keyStore=/path/to/keyStore -Djavax.net.ssl.keyStore=/path/to/trustStore -Djavax.net.ssl.keyStorePassword=yourPassword<br /><br />server = new <span style="font-weight: bold;">SSLSocketServer</span>(new ConsoleServerMonitor(), new InetSocketAddress(portNum));<br /></pre>
</div>
<p style="font-weight: bold;">Client side usage</p>
<div class="source">
<pre>jremotingClient = new JRemotingClient(new <span style="font-weight: bold;">SSLSocketTransport</span>(new ConsoleClientMonitor(), new InetSocketAddress("somehost.com", portNum)));<br /></pre>
</div><h3>Piped Transport</h3>Using Java's built-in pipes, this
transport will join two parts of the same application with RPC.
&nbsp;Interestingly you could have a large hierachy of clasloaders with
the objects to be serialized duplicated in the tree (once for client
side, once for server side) and it would work. Perhaps even if they wee
different versions of the same jar.<br /><br /><span style="font-weight: bold;">Usage</span>
<div class="source">
<pre>PipedServer server = new <span style="font-weight: bold;">PipedServer</span>(new ConsoleServerMonitor(), new InetSocketAddress(portNum));<br /><br />PipedInputStream in = new PipedInputStream();<br />PipedOutputStream out = new PipedOutputStream();<br />server.makeNewConnection(in, out);<br /><br />jremotingClient = new JRemotingClient(new <span style="font-weight: bold;">PipedTransport</span>(new ConsoleClientMonitor(), in, out));<br /><br /></pre>
</div>
Comparitive Speed.<br /><br /><br /><br /><br /><br /><h3>&nbsp;</h3>
</body></html>