<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta content="text/html;charset=ISO-8859-1" http-equiv="Content-Type" />
<title>Encoding</title></head>
<body>
<h3>Overview</h3>JRemoting has a number of 'transports' to connect
clients to servers. Some of the work over the internet, some are for
more local situations.<h3>Socket Transport</h3>This will work over the
internet or an intranet, between two different machines. &nbsp;It will
also work between two different processes on the same machine.<br /><span style="font-weight: bold;">Server side usage</span>
<div class="source">
<pre>server = new <span style="font-weight: bold;">SocketServer</span>(new ConsoleServerMonitor(), new InetSocketAddress(portNum));<br /></pre>
</div>
<p style="font-weight: bold;">Client side usage</p>
<div class="source">
<pre>jremotingClient = new JRemotingClient(new <span style="font-weight: bold;">SocketTransport</span>(new ConsoleClientMonitor(), new InetSocketAddress("somehost.com", portNum)));<br /></pre>
</div><h3>Secure Socket Transport</h3>As above, but using SSL. &nbsp;You need to set the keyStore and/or trustStore for the VM in question. See <br /><br /><span style="font-weight: bold;">Server side usage</span>
<div class="source">
<pre>-Djavax.net.ssl.keyStore=/path/to/keyStore -Djavax.net.ssl.keyStore=/path/to/trustStore -Djavax.net.ssl.keyStorePassword=yourPassword<br /><br />server = new <span style="font-weight: bold;">SSLSocketServer</span>(new ConsoleServerMonitor(), new InetSocketAddress(portNum));<br /></pre>
</div>
<p style="font-weight: bold;">Client side usage</p>
<div class="source">
<pre>jremotingClient = new JRemotingClient(new <span style="font-weight: bold;">SSLSocketTransport</span>(new ConsoleClientMonitor(), new InetSocketAddress("somehost.com", portNum)));<br /></pre>
</div><h3>Piped Transport</h3>Using Java's built-in pipes, this
transport will join two parts of the same application with RPC.
&nbsp;Interestingly you could have a large hierachy of clasloaders with
the objects to be serialized duplicated in the tree (once for client
side, once for server side) and it would work. Perhaps even if they
were different versions of the same jar. &nbsp;Pipes offers some
natural threading to the two sides of the application.<br /><br /><span style="font-weight: bold;">Usage</span>
<div class="source">
<pre>PipedServer server = new <span style="font-weight: bold;">PipedServer</span>(new ConsoleServerMonitor(), new InetSocketAddress(portNum));<br /><br />PipedInputStream in = new PipedInputStream();<br />PipedOutputStream out = new PipedOutputStream();<br />server.makeNewConnection(in, out);<br /><br />jremotingClient = new JRemotingClient(new <span style="font-weight: bold;">PipedTransport</span>(new ConsoleClientMonitor(), in, out));<br /><br /></pre>
</div>
<h3>Direct Transport</h3>Directly wiring a JRemoting server to a client
mostly serves as a quality/development consideration for us. &nbsp;The
transport is very fast as no serialization is taking place. &nbsp;If
you can find a use for it, you'l note that you can't have a complex
classloader design for this.<br /><br /><span style="font-weight: bold;">Usage</span>
<div class="source">
<pre>server = new <span style="font-weight: bold;">DirectServer</span>((ServerMonitor) mockServerMonitor.proxy());<br /><br />jremotingClient = new JRemotingClient(new <span style="font-weight: bold;">DirectTransport</span>(new ConsoleClientMonitor(), server));<br /><br /></pre>
</div>
<h3>Direct Transport, with serialization</h3>As above, but with a
delivrate serialize/deserialize step. &nbsp;Again of marginal use for
the end user compared to sockets/pipes<br /><br /><span style="font-weight: bold;">Usage</span>
<div class="source">
<pre>server = new <span style="font-weight: bold;">DirectMarshalledServer</span>((ServerMonitor) mockServerMonitor.proxy());<br /><br />jremotingClient = new JRemotingClient(new <span style="font-weight: bold;">DirectMarshalledTransport</span>(new ConsoleClientMonitor(), server));<br /><br /></pre>
</div>
<h3>Comparitive speeds</h3>On a single MacBook Pro (2.13Ghz Core2Duo)
with server and client on the same machine. &nbsp;For a 1000
invocations of&nbsp;testSpeed() over the transport in question.<br /><br />Handed Coded Proxy - 0 <br />Without Proxy (direcly wiring client to server) - 0<br /><br />Sockets<br />SSL Sockets<br />Pipes<br />Direct<br />DirectMarshalled<h3></h3><h3>Comparitive Speed.</h3><br /><br /><br /><br /><br /><h3>&nbsp;</h3>
</body></html>